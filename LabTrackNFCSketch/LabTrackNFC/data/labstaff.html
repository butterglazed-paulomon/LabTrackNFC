<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LabTrack Staff Dashboard</title>
  <link rel="stylesheet" href="/labstaff.css">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <button class="toggle-theme" onclick="toggleTheme()">Toggle Theme</button>

  <div class="container" id="pendingSection" style="display:none;">
    <h2>Return Approval Needed</h2>
    <div id="pendingBox" class="highlight-box"></div>
  </div>

  <div class="container">
    <h2>Recent Transactions (Last 20)</h2>
    <table id="recordTable">
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>Student Email</th>
          <th>Prof Email</th>
          <th>Group Members</th>
          <th>Items</th>
          <th>UID</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="footer">Made with üçû @Paulomon Edrozochu</div>

  <script>
      let lastUIDDisplayed = null;
      let flaskIP = "";
      fetch('/config.json')
        .then(res => res.json())
        .then(cfg => {
          flaskIP = cfg.flask_ip;
          loadRecords(); 
          setInterval(() => {
            if (!pendingDecision && document.hidden === false) {
              loadRecords();
            }
          }, 10000); // 10 seconds
        });
    const body = document.body;
    let darkMode = true;
    let pendingUID = null;
    let pendingDecision = false;
    let pendingTimeout = null;


    function toggleTheme() {
      darkMode = !darkMode;
      body.style.backgroundImage = darkMode ? "var(--bg-dark)" : "var(--bg-light)";
      body.style.color = darkMode ? "var(--text-light)" : "var(--text-dark)";
      document.querySelectorAll("th, td").forEach(cell => {
        cell.style.borderColor = darkMode ? "var(--border-dark)" : "var(--border-light)";
      });
    }

    function loadRecords() {
      fetch('/config.json')
        .then(res => res.json())
        .then(cfg => {
          console.log("Config loaded:", cfg);
          if (!cfg.flask_ip) throw new Error("flask_ip missing from config.json");
          return fetch(`http://${cfg.flask_ip}:8000/transactions.json`);
        })
        .then(res => res.json())
        .then(data => {
          const tbody = document.querySelector("#recordTable tbody");
          const pendingSection = document.getElementById("pendingSection");
          const pendingBox = document.getElementById("pendingBox");
          tbody.innerHTML = "";
          pendingBox.innerHTML = "";
          pendingUID = null;

          const resolvedUIDs = new Set(
            data
              .filter(tx => ["accept_return", "reject_return"].includes(tx.type))
              .map(tx => tx.uid)
          );

          const pending = data
            .filter(tx => tx.type === "confirm_return" && !tx.returned && tx.uid)
            .filter(tx => !resolvedUIDs.has(tx.uid)) 
            .filter((tx, index, self) =>
              self.findIndex(t => t.uid === tx.uid && t.returned !== true) === index
            )
            .reverse();

          if (pending.length > 0) {
          const tx = pending[0];

          if (!pendingDecision) {
            showPending(tx);
          }

          else if (pendingDecision && tx.uid !== pendingUID) {
            const confirmSwitch = confirm(`A new tag (${tx.uid}) is detected. Cancel current transaction for UID ${pendingUID}?`);

            if (confirmSwitch) {
              // Auto-reject the previous UID
              console.warn(`‚ö† Auto-rejecting ${pendingUID} to handle new tag ${tx.uid}`);
              submitDecision(pendingUID, 'reject');

              // Then display new tag
              showPending(tx);
            } else {
              console.log(`Ignoring new tag ${tx.uid} while reviewing ${pendingUID}`);
            }
          }
        }


          // Show last 20 transactions
          const recent = data.slice(-20).reverse();
          recent.forEach(tx => {
            const isReturned = tx.returned === true || tx.returned === "true";
            const statusText = isReturned ? "Returned" : "Pending";
            const tr = document.createElement("tr");
            if (isReturned) tr.classList.add("grayed-out");
            tr.innerHTML = `
              <td>${tx.timestamp}</td>
              <td>${tx.student_email}</td>
              <td>${tx.prof_email}</td>
              <td><pre>${tx.group_members}</pre></td>
              <td>${tx.items}</td>
              <td>${tx.uid}</td>
              <td>${statusText}</td>
            `;
            tbody.appendChild(tr);
          });
        });
    }
    
    function clearPendingUI() {
      document.getElementById("pendingBox").innerHTML = "";
      document.getElementById("pendingSection").style.display = "none";
      pendingUID = null;
    }
    function showPending(tx) {
      const pendingSection = document.getElementById("pendingSection");
      const pendingBox = document.getElementById("pendingBox");

      pendingDecision = true;
      pendingUID = tx.uid;
      lastUIDDisplayed = tx.uid;

      pendingBox.innerHTML = `
        <p><b>UID:</b> ${tx.uid}</p>
        <p><b>Items:</b> ${tx.items}</p>
        <p><b>Group Members:</b><br><pre>${tx.group_members}</pre></p>
        <button class="accept" onclick="submitDecision('${tx.uid}', 'accept')">Accept</button>
        <button class="reject" onclick="submitDecision('${tx.uid}', 'reject')">Reject</button>
      `;
      pendingSection.style.display = "block";

      clearTimeout(pendingTimeout);
      pendingTimeout = setTimeout(() => {
        if (pendingDecision) {
          console.warn(" Auto-clearing stale pending return UI after 30s.");
          pendingBox.innerHTML = `
            <div class="alert">
              Timeout: Staff took no action.<br>
              Please ask the student to <strong>re-tap</strong> their NFC tag.
            </div>
          `;
          pendingSection.style.display = "block";
          pendingUID = null;
          pendingDecision = false;
          lastUIDDisplayed = null;
        }
      }, 30000);
    }

    function submitDecision(uid, decision) {
      if (!confirm(`Are you sure you want to ${decision.toUpperCase()} this return?`)) return;

      fetch('/config.json')
        .then(res => res.json())
        .then(cfg => {
          if (!cfg.flask_ip) throw new Error("flask_ip is missing in config.json");
          const serverBase = `http://${cfg.flask_ip}:8000`;

          return fetch(`${serverBase}/action/${decision}/${uid}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({})
          });
        })
        .then(response => {
          if (!response.ok) throw new Error("Flask network response was not ok");
          return response.json();
        })
        .then(data => {
          alert(`Return ${decision.toUpperCase()}ED successfully.`);
          document.getElementById("pendingBox").innerHTML = "";
          document.getElementById("pendingSection").style.display = "none";
          pendingUID = null;
          pendingDecision = false;
          loadRecords();

          // Notify ESP
          fetch(`/return/${decision}`, { method: "POST" })
            .then(res => {
              if (!res.ok) throw new Error("ESP rejected the decision");
              console.log(`ESP ${decision} notified`);
            })
            .catch(err => {
              console.error("Failed to notify ESP:", err);
            });
        })
        .catch(error => {
          alert("Error submitting decision: " + error.message);
          console.error("Submit failed:", error);
        });
    }



    window.onload = () => {
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      darkMode = prefersDark;
      toggleTheme();
      //loadRecords();
      setInterval(() => {
        if (!pendingDecision && document.hidden === false) {
          loadRecords();
        }
      }, 10000);
    };
  </script>
</body>
</html>
